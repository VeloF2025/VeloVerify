<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VeloVerify Advanced - Universal Data Processing System</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #2c3e50 0%, #3498db 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.2em;
            opacity: 0.9;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            padding: 30px;
        }

        .config-section, .processing-section {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 25px;
            border: 2px solid #e9ecef;
        }

        .section-title {
            font-size: 1.5em;
            color: #2c3e50;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .config-tabs {
            display: flex;
            background: #e9ecef;
            border-radius: 8px;
            margin-bottom: 20px;
            overflow: hidden;
        }

        .tab-btn {
            flex: 1;
            padding: 12px;
            background: none;
            border: none;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
        }

        .tab-btn.active {
            background: #3498db;
            color: white;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #2c3e50;
        }

        .form-group select, .form-group input {
            width: 100%;
            padding: 12px;
            border: 2px solid #e9ecef;
            border-radius: 6px;
            font-size: 14px;
            transition: border-color 0.3s;
        }

        .form-group select:focus, .form-group input:focus {
            outline: none;
            border-color: #3498db;
        }

        .form-group select:disabled {
            background-color: #f8f9fa;
            color: #6c757d;
            cursor: not-allowed;
            border-color: #dee2e6;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .drop-zone {
            border: 3px dashed #3498db;
            border-radius: 10px;
            padding: 40px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            background: linear-gradient(45deg, #f8f9fa 0%, #e9ecef 100%);
            margin-bottom: 20px;
        }

        .drop-zone:hover, .drop-zone.dragover {
            border-color: #2980b9;
            background: linear-gradient(45deg, #e8f4fd 0%, #d1ecf1 100%);
            transform: translateY(-2px);
        }

        .drop-zone i {
            font-size: 3em;
            color: #3498db;
            margin-bottom: 15px;
        }

        .btn {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            width: 100%;
            margin-top: 10px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(52, 152, 219, 0.4);
        }

        .btn:disabled {
            background: #95a5a6;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .progress-container {
            margin: 20px 0;
            display: none;
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background: #e9ecef;
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 10px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #27ae60, #2ecc71);
            width: 0%;
            transition: width 0.3s;
            border-radius: 10px;
        }

        .progress-text {
            text-align: center;
            font-weight: 600;
            color: #2c3e50;
        }

        .results-section {
            grid-column: 1 / -1;
            background: #f8f9fa;
            border-radius: 10px;
            padding: 25px;
            border: 2px solid #e9ecef;
            margin-top: 20px;
        }

        .results-tabs {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 20px;
        }

        .result-tab {
            padding: 10px 20px;
            background: #e9ecef;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
        }

        .result-tab.active {
            background: #3498db;
            color: white;
        }

        .result-content {
            display: none;
            background: white;
            border-radius: 8px;
            padding: 20px;
            border: 1px solid #e9ecef;
        }

        .result-content.active {
            display: block;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .stat-card {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
        }

        .stat-value {
            font-size: 2em;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .stat-label {
            font-size: 0.9em;
            opacity: 0.9;
        }

        .table-container {
            max-height: 400px;
            overflow: auto;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            margin-top: 20px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
        }

        th, td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #e9ecef;
        }

        th {
            background: #f8f9fa;
            font-weight: 600;
            position: sticky;
            top: 0;
            z-index: 1;
        }

        tr:hover {
            background: #f8f9fa;
        }

        .download-section {
            display: flex;
            gap: 15px;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        .download-btn {
            background: linear-gradient(135deg, #27ae60 0%, #2ecc71 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            text-decoration: none;
            display: inline-block;
        }

        .download-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(39, 174, 96, 0.4);
        }

        .insights-panel {
            background: linear-gradient(135deg, #8e44ad 0%, #9b59b6 100%);
            color: white;
            padding: 20px;
            border-radius: 10px;
            margin-top: 20px;
        }

        .insights-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 15px;
        }

        .insight-card {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 8px;
            backdrop-filter: blur(10px);
        }

        .error-message {
            background: #e74c3c;
            color: white;
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
            display: none;
        }

        .success-message {
            background: #27ae60;
            color: white;
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
            display: none;
        }

        @media (max-width: 768px) {
            .main-content {
                grid-template-columns: 1fr;
            }
            
            .header h1 {
                font-size: 2em;
            }
            
            .stats-grid {
                grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
                            <h1>üìä VeloVerify Advanced</h1>
            <p>Universal Data Processing - Status Change & Agent Tracking System</p>
        </div>

        <div class="main-content">
            <!-- Configuration Section -->
            <div class="config-section">
                <h2 class="section-title">
                    <i class="fas fa-cogs"></i>
                    Processing Configuration
                </h2>

                <div class="config-tabs">
                    <button class="tab-btn active" onclick="switchTab('filtering')">Filtering</button>
                    <button class="tab-btn" onclick="switchTab('validation')">Validation</button>
                    <button class="tab-btn" onclick="switchTab('analysis')">Analysis</button>
                </div>

                <!-- Filtering Tab -->
                <div id="filtering-tab" class="tab-content active">
                    <div class="form-group">
                        <label for="filter-preset">Select Filter Type:</label>
                                                    <select id="filter-preset" onchange="applyFilterPreset()">
                                <option value="pole_permissions">Pole Permissions (All)</option>
                                <option value="pole_permissions_approved">Pole Permissions: Approved</option>
                                <option value="pole_permissions_declined">Pole Permissions: Declined</option>
                                <option value="home_sign_ups">Home Sign Ups (All)</option>
                                <option value="home_sign_ups_approved">Home Sign Ups: Approved</option>
                                <option value="home_sign_ups_declined">Home Sign Ups: Declined</option>
                                <option value="custom">Custom Filter</option>
                            </select>
                    </div>

                    <div class="form-group" id="filter-details">
                        <div style="background: #e8f4fd; padding: 15px; border-radius: 8px; border-left: 4px solid #3498db;">
                            <h4 style="margin: 0 0 10px 0; color: #2c3e50;">
                                <i class="fas fa-filter"></i> 
                                <span id="filter-name">Pole Permissions</span>
                            </h4>
                            <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 15px; margin-bottom: 10px;">
                                <div>
                                    <strong style="color: #27ae60;">‚úì Include:</strong>
                                    <div id="filter-include" style="font-family: monospace; color: #2c3e50;">Pole Permission: Approved</div>
                                </div>
                                <div>
                                    <strong style="color: #e74c3c;">‚úó Exclude:</strong>
                                    <div id="filter-exclude" style="font-family: monospace; color: #2c3e50;">Home Sign Ups</div>
                                </div>
                                <div>
                                    <strong style="color: #8e44ad;">üîë UID:</strong>
                                    <div id="filter-uid" style="font-family: monospace; color: #2c3e50;">Pole Number</div>
                                </div>
                            </div>
                            <div style="background: rgba(255,255,255,0.5); padding: 8px; border-radius: 4px; font-size: 0.9em; color: #555;">
                                <i class="fas fa-info-circle"></i> 
                                Filters <strong>Status</strong> column. Duplicates identified using <strong><span id="filter-uid-desc">Pole Number</span></strong> keeping earliest date for first status achievement.
                            </div>
                        </div>
                    </div>
                    
                    <div class="form-group" id="custom-filter-inputs" style="display: none;">
                        <label for="status-filter">Target Status Filter:</label>
                        <input type="text" id="status-filter" value="Pole Permission: Approved" 
                               placeholder="e.g., Pole Permission: Approved">
                        
                        <label for="exclude-filter" style="margin-top: 10px;">Exclude Filter:</label>
                        <input type="text" id="exclude-filter" value="Home Sign Ups" 
                               placeholder="e.g., Home Sign Ups">
                    </div>
                    
                    <div class="form-group">
                        <div class="checkbox-group">
                            <input type="checkbox" id="complex-flow" checked>
                            <label for="complex-flow">Handle Complex Flow Groups</label>
                        </div>
                    </div>
                    
                    <div class="form-group">
                        <div class="checkbox-group">
                            <input type="checkbox" id="case-sensitive">
                            <label for="case-sensitive">Case Sensitive Filtering</label>
                        </div>
                    </div>

                    <div class="form-group">
                        <label for="uid-field">Unique Identifier for Duplicates:</label>
                        <select id="uid-field">
                            <option value="Pole Number">Pole Number</option>
                            <option value="Drop Number">Drop Number</option>
                        </select>
                    </div>
                </div>

                <!-- Validation Tab -->
                <div id="validation-tab" class="tab-content">
                    <div class="form-group">
                        <label for="quality-level">Quality Control Level:</label>
                        <select id="quality-level">
                            <option value="strict">Strict</option>
                            <option value="standard" selected>Standard</option>
                            <option value="minimal">Minimal</option>
                        </select>
                    </div>
                    
                    <div class="form-group">
                        <div class="checkbox-group">
                            <input type="checkbox" id="validate-agents" checked>
                            <label for="validate-agents">Agent Email Validation</label>
                        </div>
                    </div>
                    
                    <div class="form-group">
                        <div class="checkbox-group">
                            <input type="checkbox" id="coordinate-validation" checked>
                            <label for="coordinate-validation">Coordinate Validation</label>
                        </div>
                    </div>
                    
                    <div class="form-group">
                        <label for="duplicate-method">Duplicate Detection Method:</label>
                        <select id="duplicate-method">
                            <option value="earliest_date" selected>Keep Earliest Date</option>
                            <option value="latest_date">Keep Latest Date</option>
                            <option value="manual_review">Manual Review</option>
                        </select>
                    </div>
                </div>

                <!-- Analysis Tab -->
                <div id="analysis-tab" class="tab-content">
                    <div class="form-group">
                        <label for="time-grouping">Time Grouping Option:</label>
                        <select id="time-grouping">
                            <option value="option_a">Complete Dataset (No Filtering)</option>
                            <option value="option_b">Monthly Breakdown</option>
                            <option value="option_c" selected>Weekly Breakdown</option>
                            <option value="option_d">Custom Date Range</option>
                        </select>
                    </div>
                    
                    <div class="form-group">
                        <button class="btn" onclick="viewAllApprovedPermissions()" style="background: linear-gradient(135deg, #27ae60 0%, #2ecc71 100%); margin-top: 10px;">
                            üëÅÔ∏è View All Filtered Records
                        </button>
                    </div>
                    
                    <div class="form-group" id="custom-date-range" style="display: none;">
                        <label for="start-date">Start Date:</label>
                        <input type="date" id="start-date">
                        <label for="end-date">End Date:</label>
                        <input type="date" id="end-date">
                    </div>
                    
                    <div class="form-group">
                        <div class="checkbox-group">
                            <input type="checkbox" id="include-summary" checked>
                            <label for="include-summary">Include Summary Sheet</label>
                        </div>
                    </div>
                    
                    <div class="form-group">
                        <div class="checkbox-group">
                            <input type="checkbox" id="include-qc" checked>
                            <label for="include-qc">Include QC Sheets</label>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Processing Section -->
            <div class="processing-section">
                <h2 class="section-title">
                    <i class="fas fa-upload"></i>
                    Data Processing
                </h2>

                <div class="drop-zone" id="drop-zone">
                    <div style="font-size: 3em; margin-bottom: 15px; color: #3498db;">üìÅ</div>
                    <h3>Drop CSV File Here</h3>
                    <p>or click to browse</p>
                    <input type="file" id="file-input" accept=".csv" style="display: none;">
                </div>

                <div id="file-info" style="display: none;">
                    <p><strong>Selected File:</strong> <span id="file-name"></span></p>
                    <p><strong>Size:</strong> <span id="file-size"></span></p>
                    <p><strong>Rows:</strong> <span id="file-rows"></span></p>
                </div>

                <div class="error-message" id="error-message"></div>
                <div class="success-message" id="success-message"></div>

                <button class="btn" id="process-btn" disabled onclick="processData()">
                    ‚ñ∂Ô∏è Process Data
                </button>

                <div class="progress-container" id="progress-container">
                    <div class="progress-bar">
                        <div class="progress-fill" id="progress-fill"></div>
                    </div>
                    <div class="progress-text" id="progress-text">Processing...</div>
                </div>
            </div>
        </div>

        <!-- Results Section -->
        <div class="results-section" id="results-section" style="display: none;">
            <h2 class="section-title">
                <i class="fas fa-chart-bar"></i>
                Processing Results
            </h2>

            <!-- Statistics Overview -->
            <div class="stats-grid" id="stats-grid"></div>

            <!-- Business Insights -->
            <div class="insights-panel">
                <h3><i class="fas fa-lightbulb"></i> Business Insights</h3>
                <div class="insights-grid" id="insights-grid"></div>
            </div>

            <!-- Results Tabs -->
            <div class="results-tabs" id="results-tabs"></div>
            
            <!-- Results Content -->
            <div id="results-content"></div>

            <!-- Download Section -->
            <div class="download-section" id="download-section"></div>
        </div>
    </div>

    <script>
        let processedData = null;
        let currentFile = null;
        let originalData = null;

        // All possible columns that might be needed
        const allPossibleColumns = [
            'Property ID',
            '1map NAD ID',
            'Pole Number',
            'Drop Number',
            'Stand Number',
            'Status',
            'Flow Name Groups',
            'Site',
            'Sections',
            'PONs',
            'Location Address',
            'Latitude',
            'Longitude',
            'Field Agent Name (pole permission)',
            'Field Agent Name (Home Sign Ups)',
            'Latitude & Longitude',
            'Last Modified Pole Permissions By',
            'Last Modified Pole Permissions Date',
            'Last Modified Home Sign Ups By',
            'Last Modified Home Sign Ups Date',
            'lst_mod_by',
            'lst_mod_dt'
        ];

        // Required columns for pole permission processing (EXACT NAMES)
        const requiredColumns = [
            'Property ID',
            '1map NAD ID',
            'Pole Number',
            'Drop Number',
            'Stand Number',
            'Status',
            'Flow Name Groups',
            'Site',
            'Sections',
            'PONs',
            'Location Address',
            'Latitude',
            'Longitude',
            'Field Agent Name (pole permission)',
            'Field Agent Name (Home Sign Ups)',
            'Latitude & Longitude',
            'Last Modified Pole Permissions By',
            'Last Modified Pole Permissions Date',
            'Last Modified Home Sign Ups By',
            'Last Modified Home Sign Ups Date',
            'lst_mod_by',
            'lst_mod_dt'
        ];

        // Filter presets configuration
        const filterPresets = {
            pole_permissions: {
                name: 'Pole Permissions (All)',
                include: 'Pole Permission',
                exclude: 'Home Sign Ups',
                uidField: 'Pole Number',
                filterColumn: 'Status',
                displayColumns: [
                    'Property ID',
                    '1map NAD ID',
                    'Pole Number',
                    'Stand Number',
                    'Status',
                    'Flow Name Groups',
                    'Site',
                    'Sections',
                    'PONs',
                    'Location Address',
                    'Latitude',
                    'Longitude',
                    'Field Agent Name (pole permission)',
                    'Last Modified Pole Permissions By',
                    'Last Modified Pole Permissions Date',
                    'Latitude & Longitude'
                ],
                description: 'Filters Status column for all pole permissions (approved and declined) using red columns'
            },
            pole_permissions_approved: {
                name: 'Pole Permissions: Approved',
                include: 'Pole Permission: Approved',
                exclude: 'Home Sign Ups',
                uidField: 'Pole Number',
                filterColumn: 'Status',
                displayColumns: [
                    'Property ID',
                    '1map NAD ID',
                    'Pole Number',
                    'Stand Number',
                    'Status',
                    'Flow Name Groups',
                    'Site',
                    'Sections',
                    'PONs',
                    'Location Address',
                    'Latitude',
                    'Longitude',
                    'Field Agent Name (pole permission)',
                    'Last Modified Pole Permissions By',
                    'Last Modified Pole Permissions Date',
                    'Latitude & Longitude'
                ],
                description: 'Filters Status column for approved pole permissions only'
            },
            pole_permissions_declined: {
                name: 'Pole Permissions: Declined',
                include: 'Pole Permission: Declined',
                exclude: 'Home Sign Ups',
                uidField: 'Pole Number',
                filterColumn: 'Status',
                displayColumns: [
                    'Property ID',
                    '1map NAD ID',
                    'Pole Number',
                    'Stand Number',
                    'Status',
                    'Flow Name Groups',
                    'Site',
                    'Sections',
                    'PONs',
                    'Location Address',
                    'Latitude',
                    'Longitude',
                    'Field Agent Name (pole permission)',
                    'Last Modified Pole Permissions By',
                    'Last Modified Pole Permissions Date',
                    'Latitude & Longitude'
                ],
                description: 'Filters Status column for declined pole permissions only'
            },
            home_sign_ups: {
                name: 'Home Sign Ups (All)',
                include: 'Home Sign Ups',
                exclude: 'Pole Permission',
                uidField: 'Drop Number',
                filterColumn: 'Status',
                displayColumns: [
                    'Property ID',
                    '1map NAD ID',
                    'Drop Number',
                    'Stand Number',
                    'Status',
                    'Flow Name Groups',
                    'Site',
                    'Sections',
                    'PONs',
                    'Location Address',
                    'Latitude',
                    'Longitude',
                    'Field Agent Name (Home Sign Ups)',
                    'Last Modified Home Sign Ups By',
                    'Last Modified Home Sign Ups Date',
                    'Latitude & Longitude'
                ],
                description: 'Filters Status column for all home sign ups (approved and declined) using yellow columns'
            },
            home_sign_ups_approved: {
                name: 'Home Sign Ups: Approved',
                include: 'Home Sign Ups: Approved',
                exclude: 'Pole Permission',
                uidField: 'Drop Number',
                filterColumn: 'Status',
                displayColumns: [
                    'Property ID',
                    '1map NAD ID',
                    'Drop Number',
                    'Stand Number',
                    'Status',
                    'Flow Name Groups',
                    'Site',
                    'Sections',
                    'PONs',
                    'Location Address',
                    'Latitude',
                    'Longitude',
                    'Field Agent Name (Home Sign Ups)',
                    'Last Modified Home Sign Ups By',
                    'Last Modified Home Sign Ups Date',
                    'Latitude & Longitude'
                ],
                description: 'Filters Status column for approved home sign ups only'
            },
            home_sign_ups_declined: {
                name: 'Home Sign Ups: Declined',
                include: 'Home Sign Ups: Declined',
                exclude: 'Pole Permission',
                uidField: 'Drop Number',
                filterColumn: 'Status',
                displayColumns: [
                    'Property ID',
                    '1map NAD ID',
                    'Drop Number',
                    'Stand Number',
                    'Status',
                    'Flow Name Groups',
                    'Site',
                    'Sections',
                    'PONs',
                    'Location Address',
                    'Latitude',
                    'Longitude',
                    'Field Agent Name (Home Sign Ups)',
                    'Last Modified Home Sign Ups By',
                    'Last Modified Home Sign Ups Date',
                    'Latitude & Longitude'
                ],
                description: 'Filters Status column for declined home sign ups only'
            },
            custom: {
                name: 'Custom Filter',
                include: '',
                exclude: '',
                uidField: 'Pole Number',
                filterColumn: 'Status',
                displayColumns: allPossibleColumns,
                description: 'Create your own custom filter criteria'
            }
        };

        // Configuration management
        const config = {
            filtering: {
                preset: 'pole_permissions',
                statusFilter: 'Pole Permission: Approved',
                excludeFilter: 'Home Sign Ups',
                complexFlow: true,
                caseSensitive: false,
                uidField: 'Pole Number'
            },
            validation: {
                qualityLevel: 'standard',
                validateAgents: true,
                coordinateValidation: true,
                duplicateMethod: 'earliest_date'
            },
            analysis: {
                timeGrouping: 'option_c',
                includeSummary: true,
                includeQC: true,
                startDate: null,
                endDate: null
            }
        };

        // Tab switching functionality
        function switchTab(tabName) {
            // Update tab buttons
            document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            
            // Update tab content
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            document.getElementById(tabName + '-tab').classList.add('active');
            
            // Show/hide custom date range
            if (tabName === 'analysis') {
                const timeGrouping = document.getElementById('time-grouping');
                const customRange = document.getElementById('custom-date-range');
                const toggleCustomRange = () => {
                    customRange.style.display = timeGrouping.value === 'option_d' ? 'block' : 'none';
                };
                timeGrouping.addEventListener('change', toggleCustomRange);
                toggleCustomRange();
            }
        }

        // Filter preset management
        function applyFilterPreset() {
            const presetSelect = document.getElementById('filter-preset');
            const selectedPreset = presetSelect.value;
            const preset = filterPresets[selectedPreset];
            
            // Update display elements
            document.getElementById('filter-name').textContent = preset.name;
            document.getElementById('filter-include').textContent = preset.include || '(none)';
            document.getElementById('filter-exclude').textContent = preset.exclude || '(none)';
            document.getElementById('filter-uid').textContent = preset.uidField;
            document.getElementById('filter-uid-desc').textContent = preset.uidField;
            
            // Update UID field automatically based on preset
            const uidSelect = document.getElementById('uid-field');
            uidSelect.value = preset.uidField;
            
            // Show/hide custom inputs
            const customInputs = document.getElementById('custom-filter-inputs');
            const filterDetails = document.getElementById('filter-details');
            
            if (selectedPreset === 'custom') {
                customInputs.style.display = 'block';
                filterDetails.style.display = 'none';
                // For custom filter, allow user to change UID field
                uidSelect.disabled = false;
            } else {
                customInputs.style.display = 'none';
                filterDetails.style.display = 'block';
                
                // Update input values for processing
                document.getElementById('status-filter').value = preset.include;
                document.getElementById('exclude-filter').value = preset.exclude;
                
                // For predefined presets, lock the UID field to prevent contradictions
                uidSelect.disabled = true;
            }
            
            // Update configuration
            config.filtering.preset = selectedPreset;
            config.filtering.statusFilter = preset.include;
            config.filtering.excludeFilter = preset.exclude;
            config.filtering.uidField = preset.uidField;
            
            console.log(`Applied filter preset: ${preset.name} (UID: ${preset.uidField})`);
        }

        // File handling
        function initFileHandling() {
            console.log('Initializing file handling...');
            
            const dropZone = document.getElementById('drop-zone');
            const fileInput = document.getElementById('file-input');

            if (!dropZone) {
                console.error('Drop zone not found!');
                return;
            }
            if (!fileInput) {
                console.error('File input not found!');
                return;
            }

            console.log('Adding event listeners...');
            
            dropZone.addEventListener('click', function() {
                console.log('Drop zone clicked');
                fileInput.click();
            });
            
            dropZone.addEventListener('dragover', function(e) {
                console.log('Drag over');
                handleDragOver(e);
            });
            
            dropZone.addEventListener('drop', function(e) {
                console.log('File dropped');
                handleDrop(e);
            });
            
            fileInput.addEventListener('change', function(e) {
                console.log('File input changed');
                handleFileSelect(e);
            });
            
            console.log('File handling event listeners added successfully');
        }

        function handleDragOver(e) {
            e.preventDefault();
            e.currentTarget.classList.add('dragover');
        }

        function handleDrop(e) {
            e.preventDefault();
            e.currentTarget.classList.remove('dragover');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                handleFile(files[0]);
            }
        }

        function handleFileSelect(e) {
            if (e.target.files.length > 0) {
                handleFile(e.target.files[0]);
            }
        }

        function handleFile(file) {
            console.log(`Handling file: ${file.name} (${file.size} bytes)`);
            
            if (!file.name.toLowerCase().endsWith('.csv')) {
                console.log('File rejected: not a CSV file');
                showError('Please select a CSV file.');
                return;
            }

            currentFile = file;
            updateFileInfo(file);
            console.log('File info updated');
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    console.log('File read successfully, parsing CSV...');
                    const csv = e.target.result;
                    originalData = parseCSV(csv);
                    console.log(`Parsed ${originalData.length} rows`);
                    
                    validateColumns(originalData);
                    console.log('Columns validated');
                    
                    document.getElementById('process-btn').disabled = false;
                    showSuccess(`File loaded successfully! Found ${originalData.length} rows.`);
                    console.log('File processing complete');
                } catch (error) {
                    console.error('Error processing file:', error);
                    showError('Error reading file: ' + error.message);
                }
            };
            
            reader.onerror = function() {
                console.error('FileReader error');
                showError('Error reading file');
            };
            
            console.log('Starting file read...');
            reader.readAsText(file);
        }

        function updateFileInfo(file) {
            document.getElementById('file-name').textContent = file.name;
            document.getElementById('file-size').textContent = formatFileSize(file.size);
            document.getElementById('file-info').style.display = 'block';
        }

        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        // CSV parsing
        function parseCSV(csv) {
            const lines = csv.split('\n').filter(line => line.trim());
            if (lines.length < 2) {
                throw new Error('CSV file must contain at least a header row and one data row.');
            }

            const headers = parseCSVLine(lines[0]);
            const data = [];

            for (let i = 1; i < lines.length; i++) {
                const values = parseCSVLine(lines[i]);
                if (values.length === headers.length) {
                    const row = {};
                    headers.forEach((header, index) => {
                        row[header.trim()] = values[index] ? values[index].trim() : '';
                    });
                    data.push(row);
                }
            }

            document.getElementById('file-rows').textContent = data.length;
            return data;
        }

        function parseCSVLine(line) {
            const result = [];
            let current = '';
            let inQuotes = false;
            
            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                
                if (char === '"') {
                    inQuotes = !inQuotes;
                } else if (char === ',' && !inQuotes) {
                    result.push(current);
                    current = '';
                } else {
                    current += char;
                }
            }
            
            result.push(current);
            return result;
        }

        // Column validation
        function validateColumns(data) {
            if (data.length === 0) {
                throw new Error('No data found in CSV file.');
            }

            const headers = Object.keys(data[0]);
            const missingColumns = requiredColumns.filter(col => !headers.includes(col));
            const extraColumns = headers.filter(header => !requiredColumns.includes(header));

            if (missingColumns.length > 0) {
                console.warn('Missing required columns:', missingColumns);
                showError(`Missing required columns: ${missingColumns.join(', ')}`);
            }

            if (extraColumns.length > 0) {
                console.info('Extra columns found (will be ignored):', extraColumns);
            }

            // Filter data to only include required columns
            data.forEach(row => {
                Object.keys(row).forEach(key => {
                    if (!requiredColumns.includes(key)) {
                        delete row[key];
                    }
                });
            });

            return true;
        }

        // Data processing
        async function processData() {
            if (!originalData) {
                showError('No data to process. Please load a CSV file first.');
                return;
            }

            updateConfig();
            showProgress(0, 'Starting data processing...');
            document.getElementById('process-btn').disabled = true;

            try {
                // Step 1: Filter data
                showProgress(10, 'Filtering data for target status...');
                const filteredData = await filterPolePermissions(originalData);

                // Step 2: Quality control
                showProgress(30, 'Performing quality control checks...');
                const qcResults = await performQualityControl(filteredData);

                // Step 3: Remove duplicates
                showProgress(50, 'Removing duplicate pole entries...');
                const { uniqueData, duplicates } = await removeDuplicates(qcResults.cleanData);

                // Step 4: Time-based analysis
                showProgress(70, 'Performing time-based analysis...');
                const analysisResults = await performTimeAnalysis(uniqueData);

                // Step 5: Generate results
                showProgress(90, 'Generating final results...');
                processedData = {
                    originalCount: originalData.length,
                    filteredCount: filteredData.length,
                    uniqueCount: uniqueData.length,
                    duplicateCount: duplicates.length,
                    analysis: analysisResults,
                    qcResults: qcResults,
                    duplicates: duplicates,
                    config: { ...config }
                };

                showProgress(100, 'Processing complete!');
                displayResults();
                
            } catch (error) {
                showError('Processing failed: ' + error.message);
                console.error('Processing error:', error);
            } finally {
                document.getElementById('process-btn').disabled = false;
                setTimeout(() => {
                    document.getElementById('progress-container').style.display = 'none';
                }, 2000);
            }
        }

        function updateConfig() {
            // Update configuration from form inputs
            config.filtering.preset = document.getElementById('filter-preset').value;
            config.filtering.statusFilter = document.getElementById('status-filter').value;
            config.filtering.excludeFilter = document.getElementById('exclude-filter').value;
            config.filtering.complexFlow = document.getElementById('complex-flow').checked;
            config.filtering.caseSensitive = document.getElementById('case-sensitive').checked;
            config.filtering.uidField = document.getElementById('uid-field').value;
            
            config.validation.qualityLevel = document.getElementById('quality-level').value;
            config.validation.validateAgents = document.getElementById('validate-agents').checked;
            config.validation.coordinateValidation = document.getElementById('coordinate-validation').checked;
            config.validation.duplicateMethod = document.getElementById('duplicate-method').value;
            
            config.analysis.timeGrouping = document.getElementById('time-grouping').value;
            config.analysis.includeSummary = document.getElementById('include-summary').checked;
            config.analysis.includeQC = document.getElementById('include-qc').checked;
            
            if (config.analysis.timeGrouping === 'option_d') {
                config.analysis.startDate = document.getElementById('start-date').value;
                config.analysis.endDate = document.getElementById('end-date').value;
            }
        }

        async function filterPolePermissions(data) {
            const currentPreset = filterPresets[config.filtering.preset] || filterPresets.pole_permissions;
            const statusFilter = currentPreset.include || config.filtering.statusFilter;
            const excludeFilter = currentPreset.exclude || config.filtering.excludeFilter;
            const filterColumn = currentPreset.filterColumn || 'Status';
            const caseSensitive = config.filtering.caseSensitive;

            return data.filter(row => {
                const columnValue = row[filterColumn] || '';
                const searchText = caseSensitive ? columnValue : columnValue.toLowerCase();
                const targetStatus = caseSensitive ? statusFilter : statusFilter.toLowerCase();
                const excludeText = caseSensitive ? excludeFilter : excludeFilter.toLowerCase();

                // Include if contains target status
                const hasTargetStatus = searchText.includes(targetStatus);
                
                // Exclude if contains exclude filter AND doesn't have target status
                const hasExcludeOnly = excludeText && searchText.includes(excludeText) && !hasTargetStatus;

                return hasTargetStatus && !hasExcludeOnly;
            });
        }

        async function performQualityControl(data) {
            const results = {
                cleanData: [],
                noPoleAllocated: [],
                agentDataMismatches: [],
                dateParseErrors: [],
                coordinateErrors: []
            };

            for (const row of data) {
                let isValid = true;
                
                // Check for missing pole numbers
                if (!row['Pole Number'] || row['Pole Number'].trim() === '') {
                    results.noPoleAllocated.push(row);
                    continue;
                }

                // Validate agent data if enabled
                if (config.validation.validateAgents) {
                    const agentName = row['Field Agent Name (pole permission)'] || '';
                    const modifiedBy = row['lst_mod_by'] || '';
                    
                    if (modifiedBy && !isValidEmail(modifiedBy)) {
                        results.agentDataMismatches.push({
                            ...row,
                            issue: 'Invalid email format in lst_mod_by'
                        });
                        if (config.validation.qualityLevel === 'strict') isValid = false;
                    }
                }

                // Validate coordinates if enabled
                if (config.validation.coordinateValidation) {
                    const lat = parseFloat(row['Latitude']);
                    const lng = parseFloat(row['Longitude']);
                    
                    if (isNaN(lat) || isNaN(lng) || lat < -90 || lat > 90 || lng < -180 || lng > 180) {
                        results.coordinateErrors.push({
                            ...row,
                            issue: 'Invalid coordinates'
                        });
                        if (config.validation.qualityLevel === 'strict') isValid = false;
                    }
                }

                // Parse and validate date
                const dateStr = row['lst_mod_dt'];
                const parsedDate = parseFlexibleDate(dateStr);
                
                if (!parsedDate) {
                    results.dateParseErrors.push({
                        ...row,
                        issue: 'Unable to parse date: ' + dateStr
                    });
                    if (config.validation.qualityLevel === 'strict') isValid = false;
                } else {
                    row._parsedDate = parsedDate;
                }

                if (isValid) {
                    results.cleanData.push(row);
                }
            }

            return results;
        }

        function parseFlexibleDate(dateStr) {
            if (!dateStr) return null;

            // Try ISO format first: "2025-07-10 16:16:48.371919+02"
            let date = new Date(dateStr);
            if (!isNaN(date.getTime())) return date;

            // Try JavaScript format: "Fri Jul 11 2025 12:50:02 GMT+0200"
            const jsDateMatch = dateStr.match(/(\w{3})\s+(\w{3})\s+(\d{1,2})\s+(\d{4})\s+(\d{1,2}):(\d{2}):(\d{2})/);
            if (jsDateMatch) {
                const [, , month, day, year, hour, minute, second] = jsDateMatch;
                const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
                                   'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                const monthIndex = monthNames.indexOf(month);
                if (monthIndex !== -1) {
                    date = new Date(year, monthIndex, day, hour, minute, second);
                    if (!isNaN(date.getTime())) return date;
                }
            }

            // Try other common formats
            const formats = [
                /(\d{4})-(\d{2})-(\d{2})/,  // YYYY-MM-DD
                /(\d{2})\/(\d{2})\/(\d{4})/,  // MM/DD/YYYY
                /(\d{2})-(\d{2})-(\d{4})/   // DD-MM-YYYY
            ];

            for (const format of formats) {
                const match = dateStr.match(format);
                if (match) {
                    date = new Date(match[0]);
                    if (!isNaN(date.getTime())) return date;
                }
            }

            return null;
        }

        function isValidEmail(email) {
            return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
        }

        async function removeDuplicates(data) {
            const uidField = config.filtering.uidField || 'Pole Number';
            const uidGroups = {};
            const duplicates = [];

            // Group by selected UID field (Pole Number or Drop Number)
            data.forEach(row => {
                const uidValue = row[uidField];
                if (!uidValue || uidValue.trim() === '') {
                    // Skip rows without UID value
                    return;
                }
                
                if (!uidGroups[uidValue]) {
                    uidGroups[uidValue] = [];
                }
                uidGroups[uidValue].push(row);
            });

            const uniqueData = [];

            // Process each UID group
            Object.values(uidGroups).forEach(group => {
                if (group.length === 1) {
                    uniqueData.push(group[0]);
                } else {
                    // Always sort by earliest date for first status achievement
                    group.sort((a, b) => {
                        const dateA = a._parsedDate || new Date(0);
                        const dateB = b._parsedDate || new Date(0);
                        return dateA - dateB; // Always earliest first
                    });

                    // Keep first entry (earliest date), mark others as duplicates
                    uniqueData.push(group[0]);
                    
                    // Add reason for duplicate marking
                    const duplicatesWithReason = group.slice(1).map(dup => ({
                        ...dup,
                        _duplicateReason: `Duplicate ${uidField}: ${group[0][uidField]} (kept earliest: ${group[0].lst_mod_dt})`
                    }));
                    
                    duplicates.push(...duplicatesWithReason);
                }
            });

            console.log(`Processed duplicates using ${uidField} as UID. Found ${duplicates.length} duplicates.`);
            return { uniqueData, duplicates };
        }

        async function performTimeAnalysis(data) {
            const timeGrouping = config.analysis.timeGrouping;
            const results = {};

            switch (timeGrouping) {
                case 'option_a':
                    // Sort data by date (newest first) for complete dataset
                    const sortedData = [...data].sort((a, b) => {
                        const dateA = a._parsedDate || new Date(0);
                        const dateB = b._parsedDate || new Date(0);
                        return dateB - dateA; // Newest first
                    });
                    results['All_First_Approvals'] = sortedData;
                    break;

                case 'option_b':
                    // Monthly breakdown
                    const monthGroups = {};
                    data.forEach(row => {
                        if (row._parsedDate) {
                            const monthKey = `${row._parsedDate.getFullYear()}-${String(row._parsedDate.getMonth() + 1).padStart(2, '0')}`;
                            if (!monthGroups[monthKey]) monthGroups[monthKey] = [];
                            monthGroups[monthKey].push(row);
                        }
                    });
                    
                    // Sort months by date (newest first) and sort data within each month
                    const sortedMonths = Object.keys(monthGroups).sort((a, b) => b.localeCompare(a));
                    sortedMonths.forEach(month => {
                        const sortedRows = monthGroups[month].sort((a, b) => {
                            const dateA = a._parsedDate || new Date(0);
                            const dateB = b._parsedDate || new Date(0);
                            return dateB - dateA;
                        });
                        results[`First_Approvals_${month}`] = sortedRows;
                    });
                    break;

                case 'option_c':
                    // Weekly breakdown (weeks ending Sunday)
                    const weekGroups = {};
                    data.forEach(row => {
                        if (row._parsedDate) {
                            const date = new Date(row._parsedDate);
                            const sunday = new Date(date);
                            sunday.setDate(date.getDate() + (7 - date.getDay()) % 7);
                            const weekKey = sunday.toISOString().split('T')[0];
                            
                            if (!weekGroups[weekKey]) weekGroups[weekKey] = [];
                            weekGroups[weekKey].push(row);
                        }
                    });
                    
                    // Sort weeks by date (newest first) and sort data within each week
                    const sortedWeeks = Object.keys(weekGroups).sort((a, b) => b.localeCompare(a));
                    sortedWeeks.forEach(week => {
                        const sortedRows = weekGroups[week].sort((a, b) => {
                            const dateA = a._parsedDate || new Date(0);
                            const dateB = b._parsedDate || new Date(0);
                            return dateB - dateA;
                        });
                        results[`Week_Ending_${week}`] = sortedRows;
                    });
                    break;

                case 'option_d':
                    // Custom date range
                    const startDate = config.analysis.startDate ? new Date(config.analysis.startDate) : null;
                    const endDate = config.analysis.endDate ? new Date(config.analysis.endDate) : null;
                    
                    const inRange = [];
                    const beforeRange = [];
                    const afterRange = [];
                    
                    data.forEach(row => {
                        if (row._parsedDate) {
                            const date = row._parsedDate;
                            
                            if (startDate && endDate) {
                                if (date >= startDate && date <= endDate) {
                                    inRange.push(row);
                                } else if (date < startDate) {
                                    beforeRange.push(row);
                                } else {
                                    afterRange.push(row);
                                }
                            } else {
                                inRange.push(row);
                            }
                        }
                    });
                    
                    // Sort all ranges by date (newest first)
                    if (inRange.length > 0) {
                        inRange.sort((a, b) => (b._parsedDate || new Date(0)) - (a._parsedDate || new Date(0)));
                        results[`First_Approvals_${config.analysis.startDate || 'All'}-${config.analysis.endDate || 'All'}`] = inRange;
                    }
                    if (beforeRange.length > 0) {
                        beforeRange.sort((a, b) => (b._parsedDate || new Date(0)) - (a._parsedDate || new Date(0)));
                        results[`First_Approvals_Before_${config.analysis.startDate}`] = beforeRange;
                    }
                    if (afterRange.length > 0) {
                        afterRange.sort((a, b) => (b._parsedDate || new Date(0)) - (a._parsedDate || new Date(0)));
                        results[`First_Approvals_After_${config.analysis.endDate}`] = afterRange;
                    }
                    break;
            }

            return results;
        }

        // Results display
        function displayResults() {
            document.getElementById('results-section').style.display = 'block';
            
            displayStatistics();
            displayBusinessInsights();
            displayResultsTabs();
            displayDownloadOptions();
            
            // Scroll to results
            document.getElementById('results-section').scrollIntoView({ behavior: 'smooth' });
        }

        function displayStatistics() {
            const statsGrid = document.getElementById('stats-grid');
            const data = processedData;
            
            statsGrid.innerHTML = `
                <div class="stat-card">
                    <div class="stat-value">${data.originalCount.toLocaleString()}</div>
                    <div class="stat-label">Total Entries</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">${data.filteredCount.toLocaleString()}</div>
                    <div class="stat-label">Filtered Entries</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">${data.uniqueCount.toLocaleString()}</div>
                    <div class="stat-label">Unique Poles</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">${data.duplicateCount.toLocaleString()}</div>
                    <div class="stat-label">Duplicates Removed</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">${Object.keys(data.analysis).length}</div>
                    <div class="stat-label">Analysis Sheets</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">${((data.uniqueCount / data.originalCount) * 100).toFixed(1)}%</div>
                    <div class="stat-label">Data Efficiency</div>
                </div>
            `;
        }

        function displayBusinessInsights() {
            const insightsGrid = document.getElementById('insights-grid');
            const analysis = processedData.analysis;
            
            // Find peak week/month
            let peakPeriod = '';
            let peakCount = 0;
            let insights = [];
            
            Object.entries(analysis).forEach(([period, data]) => {
                if (data.length > peakCount) {
                    peakCount = data.length;
                    peakPeriod = period;
                }
            });
            
            insights.push(`
                <div class="insight-card">
                    <h4><i class="fas fa-trophy"></i> Peak Period</h4>
                    <p><strong>${peakPeriod.replace(/_/g, ' ')}</strong></p>
                    <p>${peakCount.toLocaleString()} first approvals (${((peakCount / processedData.uniqueCount) * 100).toFixed(1)}% of total)</p>
                </div>
            `);
            
            // Duplicate pattern analysis
            const duplicatePercentage = ((processedData.duplicateCount / processedData.filteredCount) * 100).toFixed(1);
            insights.push(`
                <div class="insight-card">
                    <h4><i class="fas fa-copy"></i> Duplicate Pattern</h4>
                    <p><strong>${duplicatePercentage}%</strong> of filtered entries were duplicates</p>
                    <p>Indicates significant re-processing activity</p>
                </div>
            `);
            
            // Quality control insights
            const qcIssues = Object.values(processedData.qcResults).reduce((sum, arr) => sum + (Array.isArray(arr) ? arr.length : 0), 0) - processedData.qcResults.cleanData.length;
            insights.push(`
                <div class="insight-card">
                    <h4><i class="fas fa-shield-alt"></i> Data Quality</h4>
                    <p><strong>${qcIssues}</strong> quality control issues found</p>
                    <p>${((1 - qcIssues / processedData.filteredCount) * 100).toFixed(1)}% data quality score</p>
                </div>
            `);
            
            insightsGrid.innerHTML = insights.join('');
        }

        function displayResultsTabs() {
            const tabsContainer = document.getElementById('results-tabs');
            const contentContainer = document.getElementById('results-content');
            
            let tabs = [];
            let contents = [];
            
            // Sort analysis results by date (newest first) for display
            const sortedAnalysisEntries = Object.entries(processedData.analysis).sort(([nameA], [nameB]) => {
                // Extract dates from sheet names for proper sorting
                const getDateFromName = (name) => {
                    if (name.includes('Week_Ending_')) {
                        return new Date(name.replace('Week_Ending_', ''));
                    } else if (name.includes('First_Approvals_2')) {
                        const datePart = name.replace('First_Approvals_', '');
                        if (datePart.match(/^\d{4}-\d{2}$/)) {
                            return new Date(datePart + '-01');
                        }
                    } else if (name === 'All_First_Approvals') {
                        return new Date('9999-12-31'); // Show "All" first
                    }
                    return new Date(0); // Default for custom ranges
                };
                
                const dateA = getDateFromName(nameA);
                const dateB = getDateFromName(nameB);
                return dateB - dateA; // Newest first
            });
            
            // Analysis results tabs (sorted by date)
            sortedAnalysisEntries.forEach(([sheetName, data], index) => {
                const isActive = index === 0 ? 'active' : '';
                const displayName = sheetName.replace(/_/g, ' ');
                tabs.push(`<button class="result-tab ${isActive}" onclick="showResultTab('${sheetName}')">${displayName} (${data.length})</button>`);
                
                contents.push(`
                    <div id="content-${sheetName}" class="result-content ${isActive}">
                        <h3>${displayName}</h3>
                        <p><strong>Entries:</strong> ${data.length.toLocaleString()}</p>
                        <p><em>Sorted by date (newest first)</em></p>
                        ${generateDataTable(data.slice(0, 100), sheetName)}
                        ${data.length > 100 ? `<p><em>Showing first 100 rows of ${data.length.toLocaleString()} total entries.</em></p>` : ''}
                    </div>
                `);
            });
            
            // QC results tabs if enabled
            if (config.analysis.includeQC) {
                Object.entries(processedData.qcResults).forEach(([qcType, data]) => {
                    if (Array.isArray(data) && data.length > 0 && qcType !== 'cleanData') {
                        const sheetName = qcType.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase());
                        tabs.push(`<button class="result-tab" onclick="showResultTab('qc-${qcType}')">${sheetName} (${data.length})</button>`);
                        
                        contents.push(`
                            <div id="content-qc-${qcType}" class="result-content">
                                <h3>${sheetName}</h3>
                                <p><strong>Issues Found:</strong> ${data.length.toLocaleString()}</p>
                                ${generateDataTable(data.slice(0, 50), qcType)}
                                ${data.length > 50 ? `<p><em>Showing first 50 issues of ${data.length.toLocaleString()} total.</em></p>` : ''}
                            </div>
                        `);
                    }
                });
            }
            
            tabsContainer.innerHTML = tabs.join('');
            contentContainer.innerHTML = contents.join('');
        }

        function showResultTab(tabName) {
            // Update tab buttons
            document.querySelectorAll('.result-tab').forEach(tab => tab.classList.remove('active'));
            event.target.classList.add('active');
            
            // Update content
            document.querySelectorAll('.result-content').forEach(content => content.classList.remove('active'));
            const contentId = tabName.startsWith('qc-') ? `content-${tabName}` : `content-${tabName}`;
            document.getElementById(contentId).classList.add('active');
        }

        function generateDataTable(data, sheetName) {
            if (!data || data.length === 0) {
                return '<p>No data to display.</p>';
            }
            
            // Get appropriate display columns based on current filter preset
            let headers;
            if (sheetName === 'AllApproved' || sheetName === 'AllFiltered') {
                // For the "View All" modal, use preset-specific display columns
                const currentPreset = filterPresets[config.filtering.preset] || filterPresets.pole_permissions;
                headers = currentPreset.displayColumns.filter(col => data[0].hasOwnProperty(col));
            } else {
                // For processing results, use all required columns
                headers = requiredColumns.filter(col => data[0].hasOwnProperty(col));
            }
            
            let html = `
                <div class="table-container">
                    <table>
                        <thead>
                            <tr>${headers.map(header => `<th>${header}</th>`).join('')}</tr>
                        </thead>
                        <tbody>
            `;
            
            data.forEach(row => {
                html += '<tr>';
                headers.forEach(header => {
                    const value = row[header] || '';
                    html += `<td>${escapeHtml(String(value))}</td>`;
                });
                html += '</tr>';
            });
            
            html += '</tbody></table></div>';
            return html;
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function displayDownloadOptions() {
            const downloadSection = document.getElementById('download-section');
            
            const downloads = [];
            
            // Excel download
            downloads.push(`
                <button class="download-btn" onclick="downloadExcel()">
                    <i class="fas fa-file-excel"></i> Download Excel Report
                </button>
            `);
            
            // CSV downloads for each sheet
            Object.keys(processedData.analysis).forEach(sheetName => {
                downloads.push(`
                    <button class="download-btn" onclick="downloadCSV('${sheetName}')">
                        <i class="fas fa-file-csv"></i> ${sheetName.replace(/_/g, ' ')} CSV
                    </button>
                `);
            });
            
            // JSON download
            downloads.push(`
                <button class="download-btn" onclick="downloadJSON()">
                    <i class="fas fa-file-code"></i> Download JSON Report
                </button>
            `);
            
            downloads.push(`
                <button class="download-btn" onclick="downloadHTMLReport()">
                    üìä Download Visual HTML Report
                </button>
            `);
            
            downloads.push(`
                <button class="download-btn" onclick="downloadSummaryCSV()">
                    üìã Download Summary CSV Report
                </button>
            `);
            
            downloadSection.innerHTML = downloads.join('');
        }

        // Helper function to calculate date range from actual data
        function calculateDataDateRange() {
            if (!processedData || !processedData.analysis) {
                return {
                    startDate: null,
                    endDate: null,
                    activeDays: 0,
                    spanDays: 0
                };
            }
            
            let allDates = new Set();
            let minDate = null;
            let maxDate = null;
            
            // Get all data from all analysis sheets
            Object.values(processedData.analysis).forEach(sheetData => {
                if (Array.isArray(sheetData)) {
                    sheetData.forEach(row => {
                        // Look for date fields (both standard and filter-specific)
                        const dateFields = [
                            'lst_mod_dt',
                            'Last Modified Pole Permissions Date',
                            'Last Modified Home Sign Ups Date'
                        ];
                        
                        dateFields.forEach(field => {
                            if (row[field]) {
                                try {
                                    const dateStr = row[field];
                                    let parsedDate;
                                    
                                    // Handle different date formats
                                    if (dateStr.includes('-')) {
                                        parsedDate = new Date(dateStr);
                                    } else if (dateStr.includes('/')) {
                                        parsedDate = new Date(dateStr);
                                    } else {
                                        // Try parsing as-is
                                        parsedDate = new Date(dateStr);
                                    }
                                    
                                    if (!isNaN(parsedDate.getTime())) {
                                        const dateOnly = parsedDate.toISOString().split('T')[0]; // YYYY-MM-DD format
                                        allDates.add(dateOnly);
                                        
                                        if (!minDate || parsedDate < minDate) {
                                            minDate = parsedDate;
                                        }
                                        if (!maxDate || parsedDate > maxDate) {
                                            maxDate = parsedDate;
                                        }
                                    }
                                } catch (e) {
                                    // Skip invalid dates
                                }
                            }
                        });
                    });
                }
            });
            
            const activeDays = allDates.size;
            const startDate = minDate ? minDate.toISOString().split('T')[0] : null;
            const endDate = maxDate ? maxDate.toISOString().split('T')[0] : null;
            
            let spanDays = 0;
            if (minDate && maxDate) {
                spanDays = Math.ceil((maxDate - minDate) / (1000 * 60 * 60 * 24));
            }
            
            return {
                startDate,
                endDate,
                activeDays,
                spanDays
            };
        }

        // Helper functions for export information
        function getFilterInfo() {
            const currentPreset = filterPresets[config.filtering.preset] || filterPresets.pole_permissions;
            return {
                presetName: currentPreset.name,
                filterType: config.filtering.preset,
                statusFilter: currentPreset.include || config.filtering.statusFilter,
                excludeFilter: currentPreset.exclude || config.filtering.excludeFilter,
                uidField: currentPreset.uidField || config.filtering.uidField
            };
        }

        function getDateRangeInfo() {
            const timeGrouping = config.analysis.timeGrouping;
            let dateRangeText = '';
            
            switch (timeGrouping) {
                case 'option_a':
                    dateRangeText = 'All_Time';
                    break;
                case 'option_b':
                    dateRangeText = 'Last_30_Days';
                    break;
                case 'option_c':
                    dateRangeText = 'Last_7_Days';
                    break;
                case 'option_d':
                    const startDate = config.analysis.startDate || 'All';
                    const endDate = config.analysis.endDate || 'All';
                    dateRangeText = `${startDate}_to_${endDate}`;
                    break;
                default:
                    dateRangeText = 'All_Time';
            }
            
            return {
                timeGrouping: timeGrouping,
                dateRangeText: dateRangeText,
                startDate: config.analysis.startDate,
                endDate: config.analysis.endDate
            };
        }

        function generateExportFilename(baseFilename, extension, includesSummary = false) {
            const filterInfo = getFilterInfo();
            const dateInfo = getDateRangeInfo();
            const timestamp = new Date().toISOString().split('T')[0]; // YYYY-MM-DD format
            
            const summaryText = includesSummary ? '_Summary' : '';
            
            return `VeloVerify_${filterInfo.presetName.replace(/\s+/g, '_')}_${dateInfo.dateRangeText}${summaryText}_${timestamp}.${extension}`;
        }

        function generateExportHeader() {
            const filterInfo = getFilterInfo();
            const dateInfo = getDateRangeInfo();
            const timestamp = new Date().toISOString();
            
            return [
                'VeloVerify Advanced Processing Report',
                `Generated: ${timestamp}`,
                `Filter Type: ${filterInfo.presetName}`,
                `Status Filter: ${filterInfo.statusFilter}`,
                `Exclude Filter: ${filterInfo.excludeFilter}`,
                `UID Field: ${filterInfo.uidField}`,
                `Date Range: ${dateInfo.dateRangeText.replace(/_/g, ' ')}`,
                dateInfo.startDate && dateInfo.endDate ? `Custom Range: ${dateInfo.startDate} to ${dateInfo.endDate}` : '',
                `Original File: ${currentFile ? currentFile.name : 'Unknown'}`,
                ''
            ].filter(line => line !== ''); // Remove empty lines
        }

        // Download functions
        function downloadExcel() {
            // Create a comprehensive Excel-like structure in CSV format
            const sheets = [];
            const exportHeader = generateExportHeader();
            
            // Summary sheet
            if (config.analysis.includeSummary) {
                const summary = exportHeader.map(line => [line]);
                summary.push(['']);
                
                // Calculate date range and active days from the data
                const dateRangeInfo = calculateDataDateRange();
                
                summary.push(['Data Analysis:']);
                summary.push(['Start Date:', dateRangeInfo.startDate || 'No data']);
                summary.push(['End Date:', dateRangeInfo.endDate || 'No data']);
                summary.push(['Active Days with Data:', dateRangeInfo.activeDays]);
                summary.push(['Date Range Span:', dateRangeInfo.spanDays + ' days']);
                summary.push(['']);
                summary.push(['Processing Statistics:']);
                summary.push(['Total Original Entries:', processedData.originalCount]);
                summary.push(['Filtered Entries:', processedData.filteredCount]);
                summary.push(['Unique Poles:', processedData.uniqueCount]);
                summary.push(['Duplicates Removed:', processedData.duplicateCount]);
                summary.push(['']);
                summary.push(['Analysis Sheets Created:']);
                
                Object.entries(processedData.analysis).forEach(([name, data]) => {
                    summary.push([name, data.length]);
                });
                
                sheets.push({ name: 'Summary', data: summary });
            }
            
            // Add analysis sheets
            Object.entries(processedData.analysis).forEach(([name, data]) => {
                if (data.length > 0) {
                    // Use required columns in exact order for Excel export
                    const headers = requiredColumns.filter(col => data[0] && data[0].hasOwnProperty(col));
                    const sheetData = [headers];
                    
                    data.forEach(row => {
                        sheetData.push(headers.map(header => row[header] || ''));
                    });
                    
                    sheets.push({ name: name, data: sheetData });
                }
            });
            
            // Create and download ZIP file containing all sheets
            const filename = generateExportFilename('Analysis_Report', 'zip', true);
            downloadSheetsAsZip(sheets, filename.replace('.zip', ''));
        }

        function downloadCSV(sheetName) {
            const data = processedData.analysis[sheetName];
            if (!data || data.length === 0) {
                showError('No data available for this sheet.');
                return;
            }
            
            // Generate filename (no longer marked as summary)
            const filename = generateExportFilename(sheetName, 'csv', false);
            
            // Use preset-specific columns for CSV export
            const currentPreset = filterPresets[config.filtering.preset] || filterPresets.pole_permissions;
            const headers = currentPreset.displayColumns.filter(col => data[0] && data[0].hasOwnProperty(col));
            
            // Create clean CSV with only data
            let csv = '';
            
            // Add column headers
            csv += headers.join(',') + '\n';
            
            // Add data rows
            data.forEach(row => {
                const values = headers.map(header => {
                    const value = row[header] || '';
                    return `"${String(value).replace(/"/g, '""')}"`;
                });
                csv += values.join(',') + '\n';
            });
            
            downloadFile(csv, filename, 'text/csv');
        }

        function downloadSummaryCSV() {
            // Generate export header and filename
            const exportHeader = generateExportHeader();
            const dataDateRange = calculateDataDateRange();
            const filename = generateExportFilename('Summary_Report', 'csv', true);
            
            // Create comprehensive summary CSV
            let csv = '';
            
            // ===== SUMMARY SECTION =====
            csv += '=== VELOVERIFY SUMMARY REPORT ===\n';
            exportHeader.forEach(line => {
                csv += `${line}\n`;
            });
            
            csv += '\n=== DATA ANALYSIS ===\n';
            csv += `Metric,Value\n`;
            csv += `Start Date,${dataDateRange.startDate || 'No data'}\n`;
            csv += `End Date,${dataDateRange.endDate || 'No data'}\n`;
            csv += `Active Days with Data,${dataDateRange.activeDays}\n`;
            csv += `Date Range Span,${dataDateRange.spanDays} days\n`;
            
            csv += '\n=== PROCESSING STATISTICS ===\n';
            csv += `Metric,Value\n`;
            csv += `Total Original Entries,${processedData.originalCount}\n`;
            csv += `Filtered Entries,${processedData.filteredCount}\n`;
            csv += `Unique Poles,${processedData.uniqueCount}\n`;
            csv += `Duplicates Removed,${processedData.duplicateCount}\n`;
            
            // Add analysis insights if available
            const insights = generateDataInsights();
            if (insights) {
                csv += '\n=== AGENT PERFORMANCE SUMMARY ===\n';
                csv += `Metric,Value\n`;
                csv += `Total Agents,${insights.totalAgents}\n`;
                csv += `Average per Agent,${insights.avgPerAgent}\n`;
                csv += `Highest Performer,${insights.highestPerformer ? insights.highestPerformer.name : 'N/A'}\n`;
                csv += `Highest Performance Count,${insights.highestPerformer ? insights.highestPerformer.count : 0}\n`;
                csv += `Top 10 Agents Share,${insights.top10Percentage}%\n`;
                csv += `Peak Day,${insights.peakDay.date || 'N/A'}\n`;
                csv += `Peak Day Count,${insights.peakDay.count || 0}\n`;
                csv += `Agents with Multiple Emails,${insights.agentsWithMultipleEmails}\n`;
                csv += `Email Issue Rate,${insights.emailIssueRate}%\n`;
                
                csv += '\n=== TOP 10 AGENTS ===\n';
                csv += 'Rank,Agent Name,Count,Primary Email,Multiple Emails\n';
                insights.agentPerformance.slice(0, 10).forEach(agent => {
                    csv += `${agent.rank},"${agent.name}",${agent.count},"${agent.primaryEmail}",${agent.hasMultipleEmails ? 'Yes' : 'No'}\n`;
                });
                
                if (insights.dailyBreakdown.length > 0) {
                    csv += '\n=== DAILY BREAKDOWN ===\n';
                    csv += 'Date,Count,Day of Week,% of Total,Peak Day\n';
                    insights.dailyBreakdown.forEach(day => {
                        const percentage = ((day.count / insights.totalEntries) * 100).toFixed(1);
                        const isPeak = day.count === insights.peakDay.count ? 'Yes' : 'No';
                        csv += `${day.date},${day.count},"${day.dayName}",${percentage}%,${isPeak}\n`;
                    });
                }
            }
            
            // Add analysis sheets created
            csv += '\n=== ANALYSIS SHEETS CREATED ===\n';
            csv += 'Sheet Name,Record Count\n';
            Object.entries(processedData.analysis).forEach(([name, sheetData]) => {
                csv += `"${name}",${sheetData.length}\n`;
            });
            
            downloadFile(csv, filename, 'text/csv');
        }

        function downloadJSON() {
            const filterInfo = getFilterInfo();
            const dateInfo = getDateRangeInfo();
            const dataDateRange = calculateDataDateRange();
            const filename = generateExportFilename('Analysis_Report', 'json', true);
            
            const report = {
                exportInfo: {
                    generated: new Date().toISOString(),
                    filterType: filterInfo.presetName,
                    filterPreset: filterInfo.filterType,
                    statusFilter: filterInfo.statusFilter,
                    excludeFilter: filterInfo.excludeFilter,
                    uidField: filterInfo.uidField,
                    dateRange: dateInfo.dateRangeText.replace(/_/g, ' '),
                    customDateRange: dateInfo.startDate && dateInfo.endDate ? {
                        startDate: dateInfo.startDate,
                        endDate: dateInfo.endDate
                    } : null,
                    originalFile: currentFile ? currentFile.name : 'Unknown'
                },
                dataAnalysis: {
                    actualStartDate: dataDateRange.startDate,
                    actualEndDate: dataDateRange.endDate,
                    activeDaysWithData: dataDateRange.activeDays,
                    dateRangeSpanDays: dataDateRange.spanDays
                },
                metadata: {
                    configuration: config,
                    statistics: {
                        originalCount: processedData.originalCount,
                        filteredCount: processedData.filteredCount,
                        uniqueCount: processedData.uniqueCount,
                        duplicateCount: processedData.duplicateCount
                    }
                },
                analysis: processedData.analysis,
                qualityControl: processedData.qcResults
            };
            
            downloadFile(JSON.stringify(report, null, 2), filename, 'application/json');
        }

        function downloadHTMLReport() {
            const filterInfo = getFilterInfo();
            const dateInfo = getDateRangeInfo();
            const dataDateRange = calculateDataDateRange();
            const filename = generateExportFilename('Visual_Report', 'html', true);
            
            // Analyze the data for insights
            const insights = generateDataInsights();
            
            const htmlReport = generateHTMLReport(filterInfo, dateInfo, dataDateRange, insights);
            
            downloadFile(htmlReport, filename, 'text/html');
        }

        function generateDataInsights() {
            if (!processedData || !processedData.analysis) {
                return null;
            }

            // Get the main data set (first analysis sheet)
            const mainDataKey = Object.keys(processedData.analysis)[0];
            const mainData = processedData.analysis[mainDataKey] || [];
            
            if (mainData.length === 0) {
                return null;
            }

            // Daily breakdown analysis
            const dailyBreakdown = {};
            const agentPerformance = {};
            const emailTracking = {};
            let totalEntries = 0;

            // Current preset to determine which fields to use
            const currentPreset = filterPresets[config.filtering.preset] || filterPresets.pole_permissions;
            const isHomeSignUps = currentPreset.uidField === 'Drop Number';
            const agentField = isHomeSignUps ? 'Field Agent Name (Home Sign Ups)' : 'Field Agent Name (pole permission)';
            const dateField = isHomeSignUps ? 'Last Modified Home Sign Ups Date' : 'Last Modified Pole Permissions Date';
            const emailField = isHomeSignUps ? 'Last Modified Home Sign Ups By' : 'Last Modified Pole Permissions By';

            mainData.forEach(row => {
                totalEntries++;
                
                // Daily analysis
                const dateStr = row[dateField] || row['lst_mod_dt'];
                if (dateStr) {
                    try {
                        const date = new Date(dateStr);
                        const dateKey = date.toISOString().split('T')[0];
                        const dayName = date.toLocaleDateString('en-US', { weekday: 'long' });
                        
                        if (!dailyBreakdown[dateKey]) {
                            dailyBreakdown[dateKey] = {
                                count: 0,
                                dayName: dayName,
                                date: date
                            };
                        }
                        dailyBreakdown[dateKey].count++;
                    } catch (e) {
                        // Skip invalid dates
                    }
                }

                // Agent performance analysis
                const agentName = row[agentField];
                const agentEmail = row[emailField];
                
                if (agentName) {
                    const cleanAgentName = agentName.trim();
                    
                    if (!agentPerformance[cleanAgentName]) {
                        agentPerformance[cleanAgentName] = {
                            count: 0,
                            emails: new Set(),
                            primaryEmail: agentEmail || 'Unknown'
                        };
                    }
                    agentPerformance[cleanAgentName].count++;
                    
                    if (agentEmail) {
                        agentPerformance[cleanAgentName].emails.add(agentEmail);
                        
                        // Track email usage
                        if (!emailTracking[agentEmail]) {
                            emailTracking[agentEmail] = new Set();
                        }
                        emailTracking[agentEmail].add(cleanAgentName);
                    }
                }
            });

            // Sort daily data by date
            const sortedDailyData = Object.entries(dailyBreakdown)
                .sort(([a], [b]) => new Date(a) - new Date(b))
                .map(([date, data]) => ({
                    date,
                    count: data.count,
                    dayName: data.dayName,
                    dateObj: data.date
                }));

            // Find peak day
            const peakDay = sortedDailyData.reduce((max, day) => 
                day.count > max.count ? day : max, 
                { count: 0 }
            );

            // Sort agents by performance
            const sortedAgents = Object.entries(agentPerformance)
                .sort(([,a], [,b]) => b.count - a.count)
                .map(([name, data], index) => ({
                    rank: index + 1,
                    name: name,
                    count: data.count,
                    primaryEmail: data.primaryEmail,
                    emailCount: data.emails.size,
                    hasMultipleEmails: data.emails.size > 1
                }));

            // Calculate statistics
            const totalAgents = sortedAgents.length;
            const avgPerAgent = totalAgents > 0 ? (totalEntries / totalAgents).toFixed(1) : 0;
            const highestPerformer = sortedAgents[0];
            const lowestPerformers = sortedAgents.filter(agent => agent.count === Math.min(...sortedAgents.map(a => a.count)));
            
            // Data quality analysis
            const agentsWithMultipleEmails = sortedAgents.filter(agent => agent.hasMultipleEmails).length;
            const emailIssueRate = totalAgents > 0 ? ((agentsWithMultipleEmails / totalAgents) * 100).toFixed(1) : 0;

            // Performance distribution
            const top10Performance = sortedAgents.slice(0, 10).reduce((sum, agent) => sum + agent.count, 0);
            const top10Percentage = totalEntries > 0 ? ((top10Performance / totalEntries) * 100).toFixed(1) : 0;

            return {
                totalEntries,
                dailyBreakdown: sortedDailyData,
                peakDay,
                agentPerformance: sortedAgents,
                totalAgents,
                avgPerAgent,
                highestPerformer,
                lowestPerformers,
                agentsWithMultipleEmails,
                emailIssueRate,
                top10Percentage,
                currentPreset,
                agentField,
                dateField,
                emailField
            };
        }

        function generateHTMLReport(filterInfo, dateInfo, dataDateRange, insights) {
            if (!insights) {
                return '<html><body><h1>No data available for report generation</h1></body></html>';
            }

            const reportTitle = `${filterInfo.presetName} Analysis: ${dataDateRange.startDate} - ${dataDateRange.endDate}`;
            const isHomeSignUps = insights.currentPreset.uidField === 'Drop Number';
            const entityType = isHomeSignUps ? 'Sign Ups' : 'Poles';
            const entityTypeLC = entityType.toLowerCase();
            
            return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${reportTitle}</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 40px;
            text-align: center;
        }
        
        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        .content {
            padding: 40px;
        }
        
        .section {
            margin-bottom: 40px;
            background: #f8f9fa;
            border-radius: 10px;
            padding: 30px;
            border-left: 5px solid #667eea;
        }
        
        .section h2 {
            color: #2c3e50;
            font-size: 1.8em;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .section h3 {
            color: #34495e;
            font-size: 1.4em;
            margin: 25px 0 15px 0;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        
        .stat-card {
            background: white;
            padding: 20px;
            border-radius: 10px;
            border: 2px solid #e9ecef;
            text-align: center;
            transition: transform 0.3s ease;
        }
        
        .stat-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
        }
        
        .stat-number {
            font-size: 2.5em;
            font-weight: bold;
            color: #667eea;
            display: block;
        }
        
        .stat-label {
            color: #6c757d;
            margin-top: 5px;
        }
        
        .table-container {
            overflow-x: auto;
            margin: 20px 0;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            background: white;
        }
        
        th {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px;
            text-align: left;
            font-weight: 600;
        }
        
        td {
            padding: 12px 15px;
            border-bottom: 1px solid #e9ecef;
        }
        
        tbody tr:hover {
            background: #f8f9fa;
        }
        
        .peak-day {
            background: #fff3cd !important;
            border-left: 4px solid #ffc107;
        }
        
        .highlight {
            background: #e3f2fd;
            border-left: 4px solid #2196f3;
        }
        
        .quality-issue {
            background: #ffebee;
            border-left: 4px solid #f44336;
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
        }
        
        .insight-box {
            background: #e8f5e8;
            border-left: 4px solid #4caf50;
            padding: 20px;
            border-radius: 5px;
            margin: 20px 0;
        }
        
        .insight-box h4 {
            color: #2e7d32;
            margin-bottom: 10px;
        }
        
        .badge {
            display: inline-block;
            padding: 4px 8px;
            background: #dc3545;
            color: white;
            border-radius: 4px;
            font-size: 0.8em;
            margin-left: 5px;
        }
        
        .footer {
            background: #2c3e50;
            color: white;
            padding: 30px;
            text-align: center;
        }
        
        .footer p {
            margin: 5px 0;
            opacity: 0.9;
        }
        
        .emoji {
            font-size: 1.2em;
            margin-right: 5px;
        }
        
        @media (max-width: 768px) {
            .container {
                margin: 10px;
                border-radius: 0;
            }
            
            .header {
                padding: 20px;
            }
            
            .header h1 {
                font-size: 1.8em;
            }
            
            .content {
                padding: 20px;
            }
            
            .stats-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>${reportTitle}</h1>
            <p>Generated on ${new Date().toLocaleDateString('en-US', { 
                weekday: 'long', 
                year: 'numeric', 
                month: 'long', 
                day: 'numeric' 
            })}</p>
        </div>
        
        <div class="content">
            <!-- Exact Results Section -->
            <div class="section">
                <h2><span class="emoji">üìä</span>Exact Results</h2>
                <div class="stats-grid">
                    <div class="stat-card">
                        <span class="stat-number">${dataDateRange.activeDays}</span>
                        <div class="stat-label">Active Days</div>
                    </div>
                    <div class="stat-card">
                        <span class="stat-number">${insights.totalEntries.toLocaleString()}</span>
                        <div class="stat-label">${entityType} in Period</div>
                    </div>
                    <div class="stat-card">
                        <span class="stat-number">${dataDateRange.spanDays}</span>
                        <div class="stat-label">Total Days Span</div>
                    </div>
                    <div class="stat-card">
                        <span class="stat-number">${processedData.uniqueCount.toLocaleString()}</span>
                        <div class="stat-label">Total Unique ${entityType}</div>
                    </div>
                </div>
                
                <div class="insight-box">
                    <h4>üìà Key Insight</h4>
                    <p><strong>Date Range:</strong> ${dataDateRange.startDate} - ${dataDateRange.endDate} (${dataDateRange.spanDays} days)</p>
                    <p><strong>${entityType} with activity in target window:</strong> ${insights.totalEntries.toLocaleString()} ${entityTypeLC}</p>
                    <p><strong>Target window represents:</strong> ${((insights.totalEntries / processedData.uniqueCount) * 100).toFixed(2)}% of all unique ${entityTypeLC}</p>
                </div>
            </div>

            <!-- Daily Breakdown Section -->
            <div class="section">
                <h2><span class="emoji">üìÖ</span>Daily Breakdown</h2>
                <div class="table-container">
                    <table>
                        <thead>
                            <tr>
                                <th>Date</th>
                                <th>${entityType}</th>
                                <th>Day of Week</th>
                                <th>% of Total</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${insights.dailyBreakdown.map(day => {
                                const isPeakDay = day.count === insights.peakDay.count;
                                const percentage = ((day.count / insights.totalEntries) * 100).toFixed(1);
                                return `<tr ${isPeakDay ? 'class="peak-day"' : ''}>
                                    <td>${day.date}</td>
                                    <td><strong>${day.count.toLocaleString()}</strong></td>
                                    <td>${day.dayName}${isPeakDay ? ' (Peak Day)' : ''}</td>
                                    <td>${percentage}%</td>
                                </tr>`;
                            }).join('')}
                            <tr class="highlight">
                                <td><strong>Total</strong></td>
                                <td><strong>${insights.totalEntries.toLocaleString()}</strong></td>
                                <td>-</td>
                                <td><strong>100%</strong></td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>

            <!-- Agent Performance Section -->
            <div class="section">
                <h2><span class="emoji">üë•</span>Agent Performance Summary</h2>
                
                <h3>Top 10 Performing Agents</h3>
                <div class="table-container">
                    <table>
                        <thead>
                            <tr>
                                <th>Rank</th>
                                <th>Agent Name</th>
                                <th>${entityType}</th>
                                <th>Primary Email</th>
                                <th>Issues</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${insights.agentPerformance.slice(0, 10).map(agent => `
                                <tr>
                                    <td><strong>${agent.rank}</strong></td>
                                    <td>${agent.name}</td>
                                    <td><strong>${agent.count.toLocaleString()}</strong></td>
                                    <td>${agent.primaryEmail}</td>
                                    <td>${agent.hasMultipleEmails ? '<span class="badge">Multiple emails</span>' : 'None'}</td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                </div>

                <h3>Agent Statistics</h3>
                <div class="stats-grid">
                    <div class="stat-card">
                        <span class="stat-number">${insights.totalAgents}</span>
                        <div class="stat-label">Total Unique Agents</div>
                    </div>
                    <div class="stat-card">
                        <span class="stat-number">${insights.avgPerAgent}</span>
                        <div class="stat-label">Average ${entityType} per Agent</div>
                    </div>
                    <div class="stat-card">
                        <span class="stat-number">${insights.highestPerformer ? insights.highestPerformer.count : 0}</span>
                        <div class="stat-label">Highest Performing Agent</div>
                    </div>
                    <div class="stat-card">
                        <span class="stat-number">${insights.top10Percentage}%</span>
                        <div class="stat-label">Top 10 Agents Share</div>
                    </div>
                </div>

                ${insights.peakDay.count > 0 ? `
                <div class="insight-box">
                    <h4>üöÄ Peak Day Performance (${insights.peakDay.date})</h4>
                    <p><strong>Total ${entityTypeLC} on peak day:</strong> ${insights.peakDay.count.toLocaleString()}</p>
                    <p><strong>Top 5 agents on peak day:</strong></p>
                    <ul>
                        ${insights.agentPerformance.slice(0, 5).map(agent => {
                            const peakDayPercentage = ((agent.count * 0.2) / insights.peakDay.count * 100).toFixed(1); // Estimated
                            return `<li><strong>${agent.name}:</strong> ~${Math.round(agent.count * 0.2)} ${entityTypeLC} (estimated ${peakDayPercentage}% of peak day)</li>`;
                        }).join('')}
                    </ul>
                </div>
                ` : ''}
            </div>

            <!-- Data Quality Section -->
            <div class="section">
                <h2><span class="emoji">‚ö†Ô∏è</span>Data Quality Analysis</h2>
                
                <h3>Email Address Issues</h3>
                <div class="quality-issue">
                    <p><strong>${insights.agentsWithMultipleEmails} out of ${insights.totalAgents} agents (${insights.emailIssueRate}%) have multiple email addresses</strong></p>
                    <p>Only ${insights.totalAgents - insights.agentsWithMultipleEmails} agents have consistent single email usage</p>
                </div>

                <div class="insight-box">
                    <h4>‚úÖ Validation Summary</h4>
                    <p><strong>Total input entries:</strong> ${processedData.originalCount.toLocaleString()} entries</p>
                    <p><strong>Unique ${entityTypeLC} after deduplication:</strong> ${processedData.uniqueCount.toLocaleString()} ${entityTypeLC}</p>
                    <p><strong>Target window subset:</strong> ${insights.totalEntries.toLocaleString()} ${entityTypeLC} (${((insights.totalEntries / processedData.uniqueCount) * 100).toFixed(2)}%)</p>
                    <p><strong>All numerical validations:</strong> Confirmed accurate</p>
                    <p><strong>Agent traceability:</strong> 100% complete</p>
                </div>
            </div>

            <!-- Key Insights Section -->
            <div class="section">
                <h2><span class="emoji">üîç</span>Key Insights</h2>
                
                <h3>Operational Patterns</h3>
                <ul>
                    <li><strong>Peak single day:</strong> ${insights.peakDay.date} (${insights.peakDay.count.toLocaleString()} ${entityTypeLC})</li>
                    <li><strong>Consistent high performers:</strong> Top 3 agents completed ${(insights.agentPerformance.slice(0, 3).reduce((sum, agent) => sum + agent.count, 0) / insights.totalEntries * 100).toFixed(1)}% of all work</li>
                    <li><strong>Work distribution:</strong> Highly concentrated among top 10 agents (${insights.top10Percentage}% of total)</li>
                    <li><strong>Data span:</strong> ${dataDateRange.spanDays} total days with ${dataDateRange.activeDays} active days</li>
                </ul>

                <h3>Quality Indicators</h3>
                <ul>
                    <li><strong>Zero missing ${isHomeSignUps ? 'drop' : 'pole'} numbers in target window</strong></li>
                    <li><strong>Perfect email format compliance</strong></li>
                    <li><strong>Agent accountability:</strong> All entries traceable to specific agents</li>
                    <li><strong>Data integrity:</strong> All ${insights.totalEntries.toLocaleString()} entries validated</li>
                </ul>
            </div>
        </div>
        
        <div class="footer">
            <p><strong>VeloVerify Advanced Processing System</strong></p>
            <p>Filter: ${filterInfo.presetName} | Generated: ${new Date().toISOString()}</p>
            <p>Original File: ${currentFile ? currentFile.name : 'Unknown'}</p>
        </div>
    </div>
</body>
</html>`;
        }

        function downloadSheetsAsZip(sheets, filename) {
            // For simplicity, download the main summary as CSV
            // In a production environment, you'd use a library like JSZip
            const mainSheet = sheets.find(s => Object.keys(processedData.analysis)[0]);
            if (mainSheet && mainSheet.data) {
                const csv = mainSheet.data.map(row => 
                    row.map(cell => `"${String(cell).replace(/"/g, '""')}"`).join(',')
                ).join('\n');
                
                downloadFile(csv, `${filename}.csv`, 'text/csv');
            }
        }

        function downloadFile(content, filename, mimeType) {
            const blob = new Blob([content], { type: mimeType });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
        }

        // Utility functions
        function showProgress(percentage, message) {
            const progressContainer = document.getElementById('progress-container');
            const progressFill = document.getElementById('progress-fill');
            const progressText = document.getElementById('progress-text');
            
            progressContainer.style.display = 'block';
            progressFill.style.width = percentage + '%';
            progressText.textContent = message;
        }

        function showError(message) {
            const errorDiv = document.getElementById('error-message');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
            setTimeout(() => {
                errorDiv.style.display = 'none';
            }, 5000);
        }

        function showSuccess(message) {
            const successDiv = document.getElementById('success-message');
            successDiv.textContent = message;
            successDiv.style.display = 'block';
            setTimeout(() => {
                successDiv.style.display = 'none';
            }, 3000);
        }

        // View all approved pole permissions function
        function viewAllApprovedPermissions() {
            if (!originalData || originalData.length === 0) {
                showError('No data loaded. Please upload a CSV file first.');
                return;
            }

            // Get current filter configuration
            const currentPreset = filterPresets[config.filtering.preset] || filterPresets.pole_permissions;
            const statusFilter = currentPreset.include || config.filtering.statusFilter;
            const excludeFilter = currentPreset.exclude || config.filtering.excludeFilter;
            const filterColumn = currentPreset.filterColumn || 'Status';

            // Filter based on current preset
            const filteredPermissions = originalData.filter(row => {
                const columnValue = row[filterColumn] || '';
                const searchText = config.filtering.caseSensitive ? columnValue : columnValue.toLowerCase();
                const targetStatus = config.filtering.caseSensitive ? statusFilter : statusFilter.toLowerCase();
                const excludeText = config.filtering.caseSensitive ? excludeFilter : excludeFilter.toLowerCase();

                // Include if contains target status
                const hasTargetStatus = searchText.includes(targetStatus);
                
                // Exclude if contains exclude filter AND doesn't have target status
                const hasExcludeOnly = excludeText && searchText.includes(excludeText) && !hasTargetStatus;

                return hasTargetStatus && !hasExcludeOnly;
            });

            // Sort by date (newest first)
            const sortedPermissions = filteredPermissions.sort((a, b) => {
                const dateA = parseFlexibleDate(a['lst_mod_dt']) || new Date(0);
                const dateB = parseFlexibleDate(b['lst_mod_dt']) || new Date(0);
                return dateB - dateA;
            });

            // Create modal to display results
            createViewAllModal(sortedPermissions, currentPreset.name);
        }

        function createViewAllModal(data, filterName = 'Approved Permissions') {
            // Remove existing modal if present
            const existingModal = document.getElementById('view-all-modal');
            if (existingModal) {
                existingModal.remove();
            }

            // Create modal HTML
            const modal = document.createElement('div');
            modal.id = 'view-all-modal';
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.8);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 10000;
                padding: 20px;
            `;

            modal.innerHTML = `
                <div style="
                    background: white;
                    border-radius: 15px;
                    width: 95%;
                    max-width: 1200px;
                    height: 90%;
                    display: flex;
                    flex-direction: column;
                    box-shadow: 0 20px 40px rgba(0,0,0,0.3);
                ">
                    <div style="
                        background: linear-gradient(135deg, #27ae60 0%, #2ecc71 100%);
                        color: white;
                        padding: 20px;
                        border-radius: 15px 15px 0 0;
                        display: flex;
                        justify-content: space-between;
                        align-items: center;
                    ">
                        <h2><i class="fas fa-eye"></i> All ${filterName} (${data.length.toLocaleString()})</h2>
                        <button onclick="closeViewAllModal()" style="
                            background: rgba(255,255,255,0.2);
                            border: none;
                            color: white;
                            padding: 10px 15px;
                            border-radius: 8px;
                            cursor: pointer;
                            font-size: 16px;
                        ">
                            <i class="fas fa-times"></i> Close
                        </button>
                    </div>
                    
                    <div style="padding: 20px; flex: 1; overflow: hidden; display: flex; flex-direction: column;">
                        <div style="margin-bottom: 15px; display: flex; gap: 15px; align-items: center;">
                                                         <div style="color: #2c3e50; font-weight: 600;">
                                 <i class="fas fa-info-circle"></i> 
                                 Showing all ${filterName.toLowerCase()} sorted by date (newest first)
                             </div>
                            <button onclick="downloadAllApproved()" style="
                                background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
                                color: white;
                                border: none;
                                padding: 8px 16px;
                                border-radius: 6px;
                                cursor: pointer;
                                font-weight: 600;
                            ">
                                <i class="fas fa-download"></i> Download CSV
                            </button>
                        </div>
                        
                        <div style="flex: 1; overflow: auto; border: 1px solid #e9ecef; border-radius: 8px;">
                            ${generateDataTable(data, 'AllApproved')}
                        </div>
                    </div>
                </div>
            `;

            document.body.appendChild(modal);

            // Store data for download
            window.allApprovedData = data;

            // Close modal on escape key or clicking outside
            const handleKeyDown = (e) => {
                if (e.key === 'Escape') {
                    closeViewAllModal();
                }
            };

            const handleClickOutside = (e) => {
                if (e.target === modal) {
                    closeViewAllModal();
                }
            };

            document.addEventListener('keydown', handleKeyDown);
            modal.addEventListener('click', handleClickOutside);

            // Store event listeners for cleanup
            modal._keyDownListener = handleKeyDown;
            modal._clickListener = handleClickOutside;
        }

        function closeViewAllModal() {
            const modal = document.getElementById('view-all-modal');
            if (modal) {
                // Clean up event listeners
                if (modal._keyDownListener) {
                    document.removeEventListener('keydown', modal._keyDownListener);
                }
                if (modal._clickListener) {
                    modal.removeEventListener('click', modal._clickListener);
                }
                modal.remove();
            }
            window.allApprovedData = null;
        }

        function downloadAllApproved() {
            if (!window.allApprovedData) {
                showError('No data available for download.');
                return;
            }

            const data = window.allApprovedData;
            // Use preset-specific display columns for download
            const currentPreset = filterPresets[config.filtering.preset] || filterPresets.pole_permissions;
            const headers = currentPreset.displayColumns.filter(col => data[0] && data[0].hasOwnProperty(col));
            let csv = headers.join(',') + '\n';
            
            data.forEach(row => {
                const values = headers.map(header => {
                    const value = row[header] || '';
                    return `"${String(value).replace(/"/g, '""')}"`;
                });
                csv += values.join(',') + '\n';
            });
            
            const timestamp = new Date().toISOString().slice(0, 19).replace(/[T:]/g, '_');
            const presetName = currentPreset.name.replace(/\s+/g, '_');
            downloadFile(csv, `All_${presetName}_${timestamp}.csv`, 'text/csv');
        }

        // Initialize the application
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM loaded, initializing...');
            
            // Initialize file handling FIRST
            initFileHandling();
            console.log('File handling initialized');
            
            // Wait a moment before applying configuration to avoid conflicts
            setTimeout(function() {
                // Load configuration template if available
                if (typeof polePermissionConfig !== 'undefined') {
                    // Apply configuration from the JSON template
                    Object.assign(config, polePermissionConfig.veloverify_config);
                    updateFormFromConfig();
                } else {
                    // Apply default filter preset if no config template
                    applyFilterPreset();
                }
                console.log('Configuration applied');
            }, 100);
            
            console.log('VeloVerify Advanced initialized successfully!');
        });

        function updateFormFromConfig() {
            // Update form fields from configuration
            document.getElementById('filter-preset').value = config.filtering?.preset || 'pole_permissions';
            document.getElementById('status-filter').value = config.filtering?.statusFilter || 'Pole Permission: Approved';
            document.getElementById('exclude-filter').value = config.filtering?.excludeFilter || 'Home Sign Ups';
            document.getElementById('complex-flow').checked = config.filtering?.complexFlow !== false;
            document.getElementById('case-sensitive').checked = config.filtering?.caseSensitive === true;
            document.getElementById('uid-field').value = config.filtering?.uidField || 'Pole Number';
            
            document.getElementById('quality-level').value = config.validation?.qualityLevel || 'standard';
            document.getElementById('validate-agents').checked = config.validation?.validateAgents !== false;
            document.getElementById('coordinate-validation').checked = config.validation?.coordinateValidation !== false;
            document.getElementById('duplicate-method').value = config.validation?.duplicateMethod || 'earliest_date';
            
            document.getElementById('time-grouping').value = config.analysis?.timeGrouping || 'option_c';
            document.getElementById('include-summary').checked = config.analysis?.includeSummary !== false;
            document.getElementById('include-qc').checked = config.analysis?.includeQC !== false;
            
            // Apply the selected filter preset
            applyFilterPreset();
        }
    </script>
</body>
</html> 